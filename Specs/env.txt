SET Environment Specification (env.py)
=====================================

Purpose
-------
- Provide an image-first SET card game environment for agents and UIs.
- Return PIL images of the current board; accept programmatic actions to select cards or deal more cards.
- Guarantee an initial 12-card board that contains at least one valid Set (configurable).

Scope
-----
- Defines rules, state, rendering, and public API for the environment implemented in `Set/env.py`.
- Rendering is delegated to Cairo via `Utils/generate_board.generate_board_image`.

Key Concepts
------------
- Card encoding: Each card is a base-3 code in [0..80] representing 4 features: NUMBER, COLOR, SHADING, SHAPE.
- Board: Visible subset of cards dealt from the deck (12–21 cards).
- Deck: Remaining undealt cards.
- Discard: Not currently used by the public API (reserved for future use).
- Image-only I/O: Actions return a human-viewable board image; callers do not receive textual board state.

Dependencies
------------
- Python: standard library `random`, `math`, `dataclasses`, `typing`.
- Pillow (`PIL.Image`) for image objects.
- Cairo board renderer: `Utils/generate_board.generate_board_image`.

Constants and Limits
--------------------
- `DECK_SIZE = 81` (all unique SET cards).
- `INITIAL_BOARD_SIZE = 12` (starting board size).
- `BOARD_INCREASE_STEP = 3` (deal-three increment).
- `MAX_BOARD_SIZE = 21` (upper bound when dealing extras).
- `FEATURE_DIM = 4`, `FEATURE_CARDINALITY = 3`.

Data Model
----------
- Card code: `int` in [0..80].
- Board state: `List[int]` of card codes.
- Deck state: `List[int]` of remaining card codes.
- Randomness: `random.Random` seeded via constructor or `reset(seed)`.

Encoding and Rules
------------------
- `code_to_vec(code) -> (n, c, s, h)`: decodes a card to 4 features, each in {0,1,2}.
- `vec_to_code(vec) -> int`: encodes a 4-tuple of features back to a card code.
- `is_set(a, b, c) -> bool`: three cards form a Set iff for each feature the values are all equal or all distinct. Implemented via ternary sum modulo 3.
- `all_sets(codes) -> List[Tuple[int,int,int]]`: enumerates all Sets present in a collection of codes.

Rendering
---------
- Render configuration (`RenderCfg`) controls card size, grid layout, and colors.
- Dynamic grid: always 3 rows (one per card row), columns increase with card count (e.g., 12→4 cols, 15→5 cols).
- Indices overlay: Board image overlays human-friendly indices for each card position to aid selection.
- Board image generation uses `generate_board_image(codes, card_width, card_height, margin, cols, rows, overlay_indices)`.

Public API
----------
- `class SetEnv` (stateful environment)
  - Constructor: `SetEnv(seed: int | None = None, require_initial_set: bool = True)`
    - Initializes RNG, shuffles deck, deals initial board.
    - If `require_initial_set` is True, ensures at least one Set is present on the initial 12-card board (see Methodology).
  - `reset(seed: int | None = None) -> Image`
    - Re-seeds RNG (if provided), shuffles a fresh deck, deals a new board, and returns the current board image.
  - `get_board_image() -> Image`
    - Returns the current board image (with index overlays).
  - `select(indices: Tuple[int, int, int]) -> EnvReturn`
    - Propose three board positions. On valid Set: removes those cards, refills up to 12 from the deck when possible, and returns a success message plus new image.
    - On invalid Set or bad input: returns an error message plus the unchanged image.
  - `deal_three() -> EnvReturn`
    - Adds 3 cards to the board (up to `MAX_BOARD_SIZE`) if the deck has enough cards. Returns status message plus updated image.

- `class EnvReturn(NamedTuple)`
  - `message: Optional[str]` — status or error text.
  - `image: Optional[Image]` — board image corresponding to the resulting state.

Inputs and Indexing
-------------------
- Index overlay on images is human-friendly (1-based numbering on the board image).
- Method inputs use 0-based indexing for `indices` in `select(...)`. Callers must map UI numbers to 0-based (e.g., `ui_index - 1`).
- Validation:
  - Distinctness: must provide three distinct indices.
  - Range: indices must be valid positions on the current board.

Outputs and Messages
--------------------
- `select(...)` messages:
  - Distinctness error: `"Error: provide three distinct indices."`
  - Range error: `"Error: index out of range."`
  - Not a set: `"Not a Set. Try again."`
  - Success: `"Success: valid Set removed."`
- `deal_three()` messages:
  - Max size reached: `"Error: board is at maximum size."`
  - Deck depleted: `"Error: deck depleted; cannot deal more cards."`
  - Success: `"Success: dealt 3 new cards."`
- `reset(...)` returns the image directly; no message tuple is used.

State Transitions and Invariants
--------------------------------
- After a successful `select`, the board shrinks by three and is refilled from the top of the deck until it reaches 12 cards or the deck is empty.
- `deal_three` increases the board size by 3 (subject to deck availability and `MAX_BOARD_SIZE`).
- The deck is always a permutation of the remaining undealt cards; cards on the board are unique and not in the deck.
- Discard pile is not currently populated by public operations (reserved for future extension).

Implementation Methodology
--------------------------
1) Seeding and deck shuffle
   - Initialize `random.Random(seed)` to produce deterministic shuffles when a seed is provided.
   - Shuffle a list `deck = [0..80]` to create the initial deck order.

2) Initial board deal with Set guarantee
   - Deal the first 12 cards to `board`.
   - If `require_initial_set` is True, test for Sets via `all_sets(board)`. If none found, reshuffle and retry.
   - After a capped number of attempts (20), force a Set by replacing the last card with the specific card that completes a Set with the first two cards.

3) Rendering
   - Compute columns as `ceil(len(board) / 3)`, fix rows to 3.
   - Delegate to Cairo `generate_board_image(...)` with `overlay_indices=True` so the user sees numbered positions.

4) Selection handling
   - Validate that three provided indices are distinct and within range.
   - Map indices directly to `board` positions (0-based), retrieve the underlying card codes.
   - Check `is_set(a,b,c)`. On success:
     - Remove cards from `board` in descending index order to avoid reindex issues.
     - Refill from `deck` until `len(board) == 12` or `deck` is empty.

5) Deal three
   - If `len(board) >= 21`, reject the action.
   - Compute `add = min(3, 21 - len(board))` and ensure `len(deck) >= add`.
   - Move `add` cards from `deck` to `board` and return the updated image.

6) Rule evaluation
   - Use ternary arithmetic: for each feature dimension i, `(va[i] + vb[i] + vc[i]) % 3 == 0` implies all-equal or all-distinct.

Determinism and Reproducibility
-------------------------------
- Passing a fixed `seed` to the constructor or `reset(seed)` ensures reproducible shuffles and board sequences.
- All randomness is isolated to `random.Random` instance owned by the environment.

Error Handling
--------------
- All user errors return an `EnvReturn` with a descriptive `message` and the current or updated `image`.
- Out-of-range selections and duplicate indices are handled gracefully without mutating state.
- Deal requests exceeding board size limit or deck size return an error and an unchanged image.

Examples
--------
- Create environment and render initial board:
  - `env = SetEnv(seed=42)`
  - `img = env.get_board_image()` -> PIL.Image

- Select three positions displayed as 2, 5, 9 on the image overlay:
  - Convert to 0-based: `(1, 4, 8)`
  - `msg, img = env.select((1, 4, 8))`
  - On success: `msg == "Success: valid Set removed."` and `img` is the new board image.

- Deal three more cards:
  - `msg, img = env.deal_three()`
  - On success: `msg == "Success: dealt 3 new cards."`

Notes and Future Extensions
---------------------------
- Discard pile integration (tracking removed Sets) can be exposed in a future API without affecting current behavior.
- Additional render customization (colors, fonts, index badges) can be added via `RenderCfg` without changing core rules.

Traceability to Implementation
------------------------------
- Encoding and rules: `Set/env.py` functions `code_to_vec`, `vec_to_code`, `is_set`, `all_sets`.
- Rendering: `render_board` delegates to Cairo with dynamic grid.
- API: `SetEnv.reset`, `SetEnv.get_board_image`, `SetEnv.select`, `SetEnv.deal_three` implement the behaviors described above.
